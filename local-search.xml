<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>底层知识-CPU</title>
    <link href="/2020/04/07/%E5%BA%95%E5%B1%82/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86-CPU/"/>
    <url>/2020/04/07/%E5%BA%95%E5%B1%82/%E5%BA%95%E5%B1%82%E7%9F%A5%E8%AF%86-CPU/</url>
    
    <content type="html"><![CDATA[<h1><span id="底层知识-cpu">底层知识-CPU</span></h1><!-- toc --><ul><li><a href="#cpu">CPU</a><ul><li><a href="#%E5%85%B3%E4%BA%8Ecpu%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">关于CPU的基本组成:</a></li><li><a href="#%E5%85%B3%E4%BA%8Ecpu%E7%9A%84%E5%A4%9A%E6%A0%B8%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B">关于CPU的多核和多线程</a></li><li><a href="#%E5%85%B3%E4%BA%8Ecpu%E4%B8%8A%E7%9A%84%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98">关于CPU上的高速缓存</a></li><li><a href="#mesi%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE">MESI(缓存一致性协议)</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E7%BC%93%E5%AD%98%E8%A1%8C%E7%9A%84%E5%AD%98%E5%9C%A8">如何证明缓存行的存在</a></li><li><a href="#cpu-%E7%9A%84%E4%B9%B1%E5%BA%8F%E6%89%A7%E8%A1%8C">CPU 的乱序执行</a><ul><li><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81%E8%A6%81%E4%B8%8D%E8%A6%81%E5%8A%A0volatile-%E8%A6%81">单例模式-双重校验锁要不要加volatile - 要</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E7%9A%84">如何禁止指令重排的</a><ul><li><a href="#cpu%E7%BA%A7%E5%88%AB">cpu级别</a></li><li><a href="#jvm%E7%BA%A7%E5%88%AB">JVM级别</a></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB">操作系统级别</a></li><li><a href="#%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD">常见关键术语</a></li><li><a href="#%E5%90%88%E5%B9%B6%E5%86%99%E6%8A%80%E6%9C%AF-write-combining">合并写技术 Write Combining</a></li><li><a href="#%E9%9D%9E%E5%90%8C%E4%B8%80%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98-numa">非同一访问内存 NUMA</a></li></ul></li></ul></li></ul><!-- tocstop --><h2><span id="cpu">CPU</span></h2><blockquote><p>首先明白cpu是用来做运算的 例如a+b=c;  a、b就是输入数据(input)，c就是输出数据(output)，加法就是处理</p></blockquote><h3><span id="关于cpu的基本组成">关于CPU的基本组成:</span></h3><ol><li><strong>寄存器(Registers)</strong> : CPU需要使用一个叫做**存储器(也就是各种寄存器)**的东西保存输入和输出数据。以下是几种常见的寄存器<ul><li><strong>MAR</strong>: memory address register，保存将要被访问数据在内存中哪个地址处，保存的是地址值</li><li><strong>MDR</strong>: memory data register，保存从内存读取进来的数据或将要写入内存的数据，保存的是数据值</li><li><strong>AC</strong>: Accumulator，保存算术运算和逻辑运算的中间结果，保存的是数据值</li><li><strong>PC</strong>: Program Counter，保存下一个将要被执行指令的地址，保存的是地址值</li><li><strong>CIR</strong>: current instruction register，保存当前正在执行的指令</li></ul></li><li><strong>算术逻辑单元(ALU, Arithmetic Logic Unit)</strong> : CPU还要将一些常用的基本运算工具(如加法器)放进CPU，这部分负责运算。</li><li><strong>控制器</strong>(CU, Control Unit) : 负责将存储器中的数据送到ALU中去做运算，并将运算后的结果存回到存储器中。</li></ol><img src="https://qiniu.gaoch.top/bolg/底层/cpu示意图.png?imageslim" alt="冯诺依曼结构图，也就是现在计算机的结构图" style="zoom: 80%;"><center>冯诺依曼结构图，也就是现在计算机的结构图</center><h3><span id="关于cpu的多核和多线程">关于CPU的多核和多线程</span></h3><img src="https://qiniu.gaoch.top/bolg/底层/超线程cpu示意图.png?imageslim" alt="超线程CPU示意图" style="zoom:40%;"><center>超线程CPU示意图</center><ol><li>CPU的物理个数就是插在主板上的个数，每个CPU可以有多核心，每核心可能会有多线程。</li><li><strong>多核CPU的每核(每核都是一个小芯片)，在系统看来都是一个独立的CPU</strong>。</li><li><strong>对于超线程CPU来说，每核CPU可以有多个线程(数量是两个，比如1核双线程，2核4线程，4核8线程)，每个线程都是一个虚拟的逻辑CPU，而每个线程在系统看来也是独立的CPU</strong>。</li><li>多线程的CPU在能力上，比非多线程的CPU核心要更强，但每个线程不足以与独立的CPU核心能力相比较。<strong>因为多线程没有提供真正意义上的并行处理，每核CPU在某一时刻仍然只能运行一个进程，因为线程1和线程2是共享某核CPU资源的。可以简单的认为每核CPU在独立执行进程的能力上，有一个资源(上图中的ALU)是唯一的，线程1获取了该资源，线程2就没法获取</strong>。</li><li>多线程可能会出现一种现象：假如2核4线程CPU，有两个进程要被调度，那么只有两个线程会处于运行状态，如果这两个线程是在同一核上，则另一核完全空转，处于浪费状态。更期望的结果是每核上都有一个CPU分别调度这两个进程。</li></ol><h3><span id="关于cpu上的高速缓存">关于CPU上的高速缓存</span></h3><table><thead><tr><th align="center">缓存</th><th align="center">耗时</th></tr></thead><tbody><tr><td align="center">Registers</td><td align="center">1&lt;ns</td></tr><tr><td align="center">L1 cache</td><td align="center">约 1ns</td></tr><tr><td align="center">L2 cache</td><td align="center">约 3ns</td></tr><tr><td align="center">L3 cache</td><td align="center">约 15ns</td></tr><tr><td align="center">main memory</td><td align="center">约 80ns</td></tr></tbody></table><ol><li><p>缓存行大小 64byte</p><blockquote><p>缓存行：<br>缓存行越大，局部性空间效率越高，但读取时间慢<br>缓存行越小，局部性空间效率越低，但读取时间快</p></blockquote></li><li><p><strong>最高速的缓存是CPU的寄存器</strong>，它们和CPU的材料相同，最靠近CPU或最接近CPU，访问它们没有时延(&lt;1ns)。但容量很小，小于1kb。</p><ul><li>32bit：32*32比特=128字节</li><li>64bit：64*64比特=512字节</li></ul></li><li><p>寄存器之下，是CPU的高速缓存。分为L1缓存、L2缓存、L3缓存，每层速度按数量级递减、容量也越来越大。</p></li><li><p>**每核心都有一个自己的L1缓存。L1缓存分两种：L1指令缓存(L1-icache)和L1数据缓存(L1-dcache)**。</p><blockquote><p>L1指令缓存用来存放已解码指令，L1数据缓存用来放访问非常频繁的数据。</p><p>L2缓存用来存放近期使用过的内存数据。更严格地说，存放的是很可能将来会被CPU使用的数据。</p></blockquote></li><li><p><strong>多数多核CPU的各核都各自拥有一个L2缓存，但也有多核共享L2缓存的设计。无论如何，L1是各核私有的(但对某核内的多线程是共享的)</strong>, L3 缓存一定是CPU共享的。</p><img src="https://qiniu.gaoch.top/blog/底层/多核cpu示意图.png?imageslim" alt="多核cpu示意图" style="zoom:35%;"></li></ol><center>多核cpu示意图</center><h3><span id="mesi缓存一致性协议">MESI(缓存一致性协议)</span></h3><img src="https://qiniu.gaoch.top/blog/底层/MESI缓存层级示意图.png?imageslim" alt="MESI缓存层级示意图" style="zoom:35%;"><center>MESI缓存层级示意图</center><blockquote><p>现在大多数CPU都是多核，并且每一个核都有自己的L1、L2缓存，那么不同的CPU或者不同核访问同一个变量的是如何进行同步的呢，这就是用到了MESI协议了。</p><p>首先我们可以认为缓存是被细分为很多个缓存行的，而不同的缓存之间传输的也是缓存行。</p></blockquote><p>两个线程同时进行 i = i +1操作(i初始值是0)，预期结果是2，但可能出现的结果是1</p><blockquote><p>当线程执行这个语句时，会先从主存当中读取i的值，然后<strong>复制</strong>一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到<strong>内存(主存)**。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入</strong>内存(主存)**。</p></blockquote><p>解决缓存缓存一致性问题的方法</p><ol><li><p>通过在总线加LOCK#锁的方式</p><blockquote><p>在总线上加LOCK#锁的形式来解决缓存不一致的问题，会阻塞了其他CPU对其他部件访问， 效率低下</p></blockquote></li><li><p>通过<strong>缓存一致性</strong>协议</p><blockquote><p>如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态</p></blockquote></li></ol><p>在MESI协议中缓存行被标记为四种状态：</p><blockquote><p>E（exclusive）、M（modified）、S（shared）、I（invalid）。下面我们介绍一下这四个状态分别代表什么意思。</p><p>M：代表该缓存行中的内容被<strong>修改</strong>了，并且<strong>该缓存行只被缓存在该CACHE中</strong>。这个状态的<strong>缓存行中的数据和内存中的不一样</strong>，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时（个人理解CPU要修改该内存时先要读取到缓存中再进行修改），这样的话和读取缓存中的内容其实是一个道理）。</p><p>E：E代表该缓存行对应内存中的<strong>内容只被该CPU缓存</strong>，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的<strong>缓存行中的内容和内存中的内容一致</strong>。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。</p><p>S:该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态。</p><p>I：代表该缓存行中的内容时无效的。</p></blockquote><h3><span id="如何证明缓存行的存在">如何证明缓存行的存在</span></h3><blockquote><p>运行并对比下列代码 会发现永远是02更快，原因就是02的两个数处于不同的缓存行上。</p><p>JDK8，加入了<code>@Contended</code>注解, 需要加上：<code>JVM -XX:-RestrictContended</code> 不再需要使用变量来占位了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheLineDemo01</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> x = <span class="hljs-number">0L</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] arr = <span class="hljs-keyword">new</span> T[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> T();<br>    arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> T();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000L</span>; i++) &#123;<br>        arr[<span class="hljs-number">0</span>].x = i;<br>      &#125;<br>    &#125;);<br><br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000L</span>; i++) &#123;<br>        arr[<span class="hljs-number">1</span>].x = i;<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = System.nanoTime();<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    System.out.println((System.nanoTime() - start)/<span class="hljs-number">100_0000</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheLineDemo02</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Padding</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> p1, p2, p3, p4, p5, p6, p7;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Padding</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> x = <span class="hljs-number">0L</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T[] arr = <span class="hljs-keyword">new</span> T[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-keyword">static</span> &#123;<br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> T();<br>    arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> T();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000L</span>; i++) &#123;<br>        arr[<span class="hljs-number">0</span>].x = i;<br>      &#125;<br>    &#125;);<br><br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">long</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000_0000L</span>; i++) &#123;<br>        arr[<span class="hljs-number">1</span>].x = i;<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> start = System.nanoTime();<br>    t1.start();<br>    t2.start();<br>    t1.join();<br>    t2.join();<br>    System.out.println((System.nanoTime() - start)/<span class="hljs-number">100_0000</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3><span id="cpu-的乱序执行">CPU 的乱序执行</span></h3><blockquote><p>乱序执行也就是同时执行， 将两个不相干的命令在两个核上同时计算提高效率。</p><p>下面代码如果没有乱序执行是不会出现(0,0)的结果的</p><p>为啥会出现0,0 结果呢， 因为两个线程中的两个赋值语句相互没有关联，当先执行了x=b,y=a 之后再执行a=1,b=1的时候就会出现0,0结果，概率很小但会出现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CPUDisOrderDemo</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b =<span class="hljs-number">0</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;;) &#123;<br>      i++;<br>      x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;<br>      a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>;<br>      Thread one = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          <span class="hljs-comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span><br>          <span class="hljs-comment">//shortWait(100000);</span><br>          a = <span class="hljs-number">1</span>;<br>          x = b;<br>        &#125;<br>      &#125;);<br><br>      Thread other = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>          b = <span class="hljs-number">1</span>;<br>          y = a;<br>        &#125;<br>      &#125;);<br>      one.start();other.start();<br>      one.join();other.join();<br>      String result = <span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次 (&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;）&quot;</span>;<br>      <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>        System.err.println(result);<br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//System.out.println(result);</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 执行结果: 第597661次 (0,0）</span><br></code></pre></td></tr></table></figure><h4><span id="单例模式-双重校验锁要不要加volatile-要">单例模式-双重校验锁要不要加volatile - 要</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewObject</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Object o = <span class="hljs-keyword">new</span> Object();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>新建java文件</p><p><strong>javac NewObject.java</strong></p><p><strong>javap -c NewObject</strong></p><p>可看jvm字节码，当然也可以使用idea插件<strong>jclasslib</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">0: new           #2   （申请一块内存）                    // class java/lang/Object<br><span class="hljs-number">3</span>: dup                （复制顶部操作数堆栈值）<br>4: invokespecial #1    (调用特殊方法，这里调用的是构造方法)  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br><span class="hljs-number">7</span>: astore_1            (将引用存储到局部变量中,就是建立o的引用关系)<br><span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>简单来说创建对象分为3步骤:</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建单例的代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getUniqueInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><h3><span id="如何禁止指令重排的">如何禁止指令重排的</span></h3><h4><span id="cpu级别">cpu级别</span></h4><ol><li><p>内存屏障：两条指令，如果不想让它重排，在两条指令中间加一道屏障。即 屏障两侧的写指令不能重排</p><blockquote><p>sfence：save| 在sfence指令前的写操作当必须在sfence指令后的写操作前完成<br>lfence：load| 在lfence指令前的写操作当必须在lfence指令后的写操作前完成<br>mfence：mix| 在mfence指令前的写操作当必须在mfence指令后的写操作前完成</p></blockquote></li></ol><ol start="2"><li>除了内存屏障，也可以使用原子指令，如x86上的”lock…” lock后面的指令不允许重排序</li></ol><img src="https://qiniu.gaoch.top/blog/底层/内存屏障示意图.png?imageslim" alt="内存屏障示意图" style="zoom:40%;"><center>内存屏障示意图</center><h4><span id="jvm级别">JVM级别</span></h4><ol><li><p>LoadLoad屏障：</p><blockquote><p>对于这样的语句Load1;LoadLoad;Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕</p></blockquote></li><li><p>SroreStore屏障：</p><blockquote><p>对于这样的语句Store1;SroreStore;Store2，在Store2及后续写入操作要读取的数据被访问前，保证Store1的写入操作对其他处理器可见</p></blockquote></li><li><p>LoadStore屏障：</p><blockquote><p>对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</p></blockquote></li><li><p>StoreLoad屏障：</p><blockquote><p>对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见</p></blockquote></li></ol><h4><span id="操作系统级别">操作系统级别</span></h4><ol><li><p>字节码层面 ,编译完成在Class文件上加了ACC_VOLATILE</p></li><li><p>JVM层面读到ACC_VOLATILE时，会内存区的读写 都加屏障</p><blockquote><p>StoreStoreBarrier<br><strong>volatile 写操作</strong><br>StoreLoadBarrier<br>LoadLoadBarrier<br><strong>volatile 读操作</strong><br>LoadStoreBarrier</p></blockquote></li></ol><p>3.操作系统OS实现</p><blockquote><p>windows lock 指令实现 或者 MESI实现</p></blockquote><h4><span id="常见关键术语">常见关键术语</span></h4><p><strong>8个hanppens-before原则:</strong></p><blockquote><ol><li><p><strong>程序次序规则</strong>： 在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作<br>（<strong>同一个线程中前面的所有写操作对后面的操作可见</strong>）</p></li><li><p><strong>管理锁定规则</strong>：一个unlock操作happen—before后面（时间上的先后顺序）对同一个锁的lock操作。<br>（<strong>如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）</strong>）</p></li><li><p><strong>volatile变量规则</strong>：对一个volatile变量的写操作happen—before后面（时间上）对该变量的读操作。<br>（<strong>如果线程1写入了volatile变量v（临界资源），接着线程2读取了v，那么，线程1写入v及之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）</strong>）</p></li><li><p><strong>线程启动规则</strong>：Thread.start()方法happen—before调用用start的线程前的每一个操作。<br>（<strong>假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A在对变量修改线程B未必可见。</strong>）</p></li><li><p><strong>线程终止规则</strong>：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。<br>(<strong>线程t1写入的所有变量，在任意其它线程t2调用t1.join()，或者t1.isAlive() 成功返回后，都对t2可见。</strong>)</p></li><li><p><strong>线程中断规则</strong>：对线程interrupt()的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。<br>(<strong>线程t1写入的所有变量，调用Thread.interrupt()，被打断的线程t2，可以看到t1的全部操作</strong>)</p></li><li><p><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。<br>(<strong>对象调用finalize()方法时，对象初始化完成的任意操作，同步到全部主存同步到全部cache。</strong>)</p></li><li><p><strong>传递性</strong>：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。<br>（<strong>A h-b B ， B h-b C 那么可以得到 A h-b C</strong>）</p></li></ol></blockquote><p><strong>as-if-serial</strong>:</p><p> 的含义: 不管硬件什么顺序，单线程执行的结果不变，看上去就像是顺序执行的一样。</p><h4><span id="合并写技术-write-combining">合并写技术 Write Combining</span></h4><blockquote><p> 寄存器和L1缓存之间还有一个buffer，空间特别小。另外还有一个WC(Write Combining)Buffer，一般是4个字节<br> 由于ALU速度太快，所以在写入L1的同时，写入一个WC Buffer，满了之后，写满4个字节之后，才会一次性刷到缓存L2里。可以用程序证明。(不要使用超线程)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WriteCombining</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = Integer.MAX_VALUE;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITEMS = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">24</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MASK = ITEMS - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] arrayA = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[ITEMS];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] arrayB = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[ITEMS];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] arrayC = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[ITEMS];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] arrayD = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[ITEMS];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] arrayE = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[ITEMS];<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] arrayF = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[ITEMS];<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>      System.out.println(i + <span class="hljs-string">&quot; SingleLoop duration (ns) = &quot;</span> + runCaseOne());<br>      System.out.println(i + <span class="hljs-string">&quot; SplitLoop  duration (ns) = &quot;</span> + runCaseTwo());<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">runCaseOne</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> start = System.nanoTime();<br>    <span class="hljs-keyword">int</span> i = ITERATIONS;<br><br>    <span class="hljs-keyword">while</span> (--i != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">int</span> slot = i &amp; MASK;<br>      <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) i;<br>      arrayA[slot] = b;<br>      arrayB[slot] = b;<br>      arrayC[slot] = b;<br>      arrayD[slot] = b;<br>      arrayE[slot] = b;<br>      arrayF[slot] = b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> System.nanoTime() - start;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">runCaseTwo</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 一次正好写满一个四字节的 Buffer，比上面的循环效率更高</span><br>    <span class="hljs-keyword">long</span> start = System.nanoTime();<br>    <span class="hljs-keyword">int</span> i = ITERATIONS;<br>    <span class="hljs-keyword">while</span> (--i != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">int</span> slot = i &amp; MASK;<br>      <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) i;<br>      arrayA[slot] = b;<br>      arrayB[slot] = b;<br>      arrayC[slot] = b;<br>    &#125;<br>    i = ITERATIONS;<br>    <span class="hljs-keyword">while</span> (--i != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">int</span> slot = i &amp; MASK;<br>      <span class="hljs-keyword">byte</span> b = (<span class="hljs-keyword">byte</span>) i;<br>      arrayD[slot] = b;<br>      arrayE[slot] = b;<br>      arrayF[slot] = b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> System.nanoTime() - start;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4><span id="非同一访问内存-numa">非同一访问内存 NUMA</span></h4><blockquote><p>UMA：同一内存访问。多个CPU通过一条总线，访问同一个内存。<br>现在很多服务器的架构是使用NUMA的，因为UMA不以拓展：随着CPU的数量增多，许多时间被浪费在CPU争抢内存资源上。<br><img src="https://qiniu.gaoch.top/blog/底层/UMA内存示意图.png?imageslim" alt="UMA内存示意图" style="zoom:60%;"></p></blockquote><center>UMA内存示意图</center><blockquote><p>NUMA：非同一访问内存。每个CPU有自己专属的内存，CPU对于自己插槽上的内存访问是有优先级的。<br><img src="https://qiniu.gaoch.top/blog/底层/NUMA内存示意图.png?imageslim" alt="NUMA内存示意图" style="zoom:60%;"></p></blockquote><center>NUMA内存示意图</center><blockquote><p>ZGC 可以做到 NUMA aware，如果探测到计算机实现了NUMA的话，分配内存会优先分配该线程所在CPU的最近内存。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>底层知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>底层知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前言</title>
    <link href="/2020/04/03/about/%E5%89%8D%E8%A8%80/"/>
    <url>/2020/04/03/about/%E5%89%8D%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1><span id="前言">前言</span></h1><ol><li>该项目主要用于记录自己的学习过程。</li><li>大部分内容来源于自己学习的笔记，经过整理后发出来的。</li><li>部门内容可能来源于很久之前的笔记，所以有些东西可能过于简单，但是我也记录下来了。还有一些可能已经过时了，已经有新技术出现了，后面我会重新学习并更新这些内容。</li><li>如果发现内容和网上的内容有相似之处，可能就是当时我照着哪些文章学习的，历史悠久没有记录文章来源，发现后会标记参考文章。</li></ol>]]></content>
    
    
    <categories>
      
      <category>about</category>
      
    </categories>
    
    
    <tags>
      
      <tag>about</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
